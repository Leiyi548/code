# [7. 整数反转](https://leetcode.cn/problems/reverse-integer/)

## Description

Difficulty: **中等**

Related Topics: [数学](https://leetcode.cn/tag/math/)

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围  [−2<sup>31</sup>,  2<sup>31 </sup>− 1] ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

**示例 1：**

```
输入：x = 123
输出：321
```

**示例 2：**

```
输入：x = -123
输出：-321
```

**示例 3：**

```
输入：x = 120
输出：21
```

**示例 4：**

```
输入：x = 0
输出：0
```

**提示：**

- -2<sup>31</sup> <= x <= 2<sup>31</sup> - 1

## Solution

Language: **Go**

**解题思路**
首先，我们想一下，怎么去反转一个整数？
用栈？
或者把整数变成字符串，再去反转字符串？
这两种方式是可以，但并不好。实际上我们只要拿到这个整数的 **末尾数字**就可以了。
以 `12345`为例，先拿到`5`，再拿到`4`，之后是`3`,`2`,`1`，我们按这样顺序就可以反向拼接处一个数字了，也就能达到反转的效果。

![](https://cdn.jsdelivr.net/gh/Leiyi548/Figure-bed//img/20220930144333.png)

1. 将 12345 % 10 得到 5，之后将 12345 / 10
2. 将 1234 % 10 得到 4，再将 1234 / 10
3. 将 123 % 10 得到 3，再将 123 / 10
4. 将 12 % 10 得到 2，再将 12 / 10
5. 将 1 % 10 得到 1，再将 1 / 10

这么看起来，一个循环就搞定了，循环的判断条件是 x>0
但这样不对，因为忽略了**负数**
循环的判断条件应该是 `while(x!=0)`，无论正数还是负数，按照上面不断的/10 这样的操作，最后都会变成 0，所以判断终止条件就是!=0
有了取模和除法操作，对于像 12300 这样的数字，也可以完美的解决掉了。

```go
func reverse(x int) int {
	res := 0
	for x != 0 {
		// 每次取末尾数字
		tmp := x % 10
		// 因为 -2^31 <= x <= 2^31 - 1
		// 判断是否大于最大32位整
		if res > 214748364 || (res == 214748364 && tmp > 7) {
			return 0
		}
		// 判断是否小于最小32位整
		if res < -214748364 || (res == -214748364 && tmp < -8) {
			return 0
		}
		res = res*10 + tmp
		x /= 10
	}
	return res
}
```
