# [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

## Description

Difficulty: **中等**

Related Topics: [双指针](https://leetcode.cn/tag/two-pointers/), [字符串](https://leetcode.cn/tag/string/), [字符串匹配](https://leetcode.cn/tag/string-matching/)

给你两个字符串  `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果  `needle` 不是 `haystack` 的一部分，则返回   `-1`。

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```

**提示：**

- 1 <= haystack.length, needle.length <= 10<sup>4</sup>
- `haystack` 和 `needle` 仅由小写英文字符组成

## 朴素解法

直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配：

- 匹配成功：返回本次匹配的原串「发起点」。
- 匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。

Language: **Go**

```go
func strStr(haystack string, needle string) int {
	n := len(haystack)
	m := len(needle)
	findIndex := 0
	for findIndex < n-m+1 {
		// 如果第一個字符不同的話，那麽直接跳過
		for haystack[findIndex] != needle[0] && findIndex < n-m {
			findIndex++
		}
		if haystack[findIndex:findIndex+m] == needle {
			return findIndex
		}
		findIndex++
	}
	return -1
}
```

**复杂度分析：**

- 时间复杂度：`n` 为原串的长度，$m$ 为匹配串的长度，其中枚举的复杂度为 $O(n-m)$，故为 $O_n$
- 空间复杂度：上面的程序就分配了 findIndex,n,m,就 findIndex 在进行改变，故为 $O_1$
